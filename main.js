import {
  checkIfElementsAreEqual,
  checkIfElementsDifferByOne,
} from "./helpers.js";

export class Battleship {
  constructor() {
    this.height = 0;
    this.width = 0;
    // All cells. for a 10x10 board there are 100 cells
    this.allCells = [];
    // All cells with ships in them and cells that surrond the ships
    this.blockedCells = [];
    // Array of all ships, e.g [ ['0-0','0-1','0,2'], ['5-5','5-6'] ]
    this.allShips = [];
    // Ships that were not hit. It equals to all ships at the start of the game
    this.remainingShips = [];
    // Array of cells that your opponent missed.
    this.misses = new Set();
    // Array of cells that your opponent hit.
    this.hits = new Set();
    // Availale cells to make moves. Those that are not misses or hits.
    this.untouchedCells = [];
    // if gameLost is true can't make moves
    this.gameLost = false;
  }
  // Sets the list of all cells and available cells. The size of the array is h*w
  // This is a helper method for .randomBoard method
  initializeBoardSize(h, w) {
    if (!Number.isInteger(h) || !Number.isInteger(w)) {
      throw new Error("Height and width must be integers");
    }
    if (h < 5 || h > 26 || w < 5 || w > 26) {
      throw new Error("Height and width must be between 5 and 26 inclusive");
    }

    this.height = h;
    this.width = w;

    for (let i = 65; i < 65 + this.height; i += 1) {
      for (let j = 1; j <= this.width; j += 1) {
        this.allCells.push(`${String.fromCharCode(i)}${j}`);
        this.untouchedCells.push(`${String.fromCharCode(i)}${j}`);
      }
    }
  }
  // Generates a random board. The array is the sizes of ships.
  // e.g. [5,4,3,3] means 1 ship of 5 squares, 1 ship of 4 squares, and 2 ships of 3 squares.

  reset() {
    this.height = null;
    this.width = null;
    this.allCells = [];
    this.blockedCells = [];
    this.allShips = [];
    this.remainingShips = [];
    this.misses = new Set();
    this.hits = new Set();
    this.untouchedCells = [];
    this.gameLost = false;
  }

  randomBoard([h, w], arrayOfShipSizes) {
    try {
      this.reset();
      this.initializeBoardSize(h, w);
      arrayOfShipSizes.forEach(e => {
        const ship = this.generateShipCoords(e);
        this.placeShipAndBlockSurroundingCells(ship);
      });
    } catch (err) {
      console.error(err);
      this.reset();
    }
  }

  randomInteger(upperLimit) {
    /**
     * Returns a random number between 0 and upperLimit inclusive
     * @param number upperLimit - positive integer
     * @return number - a random number between 0 and upperLimit inclusive
     */
    return Math.floor(Math.random() * (upperLimit + 1));
  }

  chooseRandomDirection() {
    return this.randomInteger(1) ? "horizontal" : "vertical";
  }

  possibleShipStartingCells(shipSize, direction) {
    /**
     * Loops over all cells and checks if the ship of size shipSize and at given direction
     * can start at each cell
     * @param integer - shipSize
     * @param string - direction. Can be either 'horizontal' or 'vertical'
     * @return Array of cells at which the ship can start
     */

    const arrayOfCells = [];

    // for horizontal cells the adjacent cells are 1 away, for vertical - the width of the board
    const step = direction === "horizontal" ? 1 : this.width;

    outerLoop: for (let i = 0; i < this.allCells.length; i += 1) {
      const potentialShipCells = [];
      for (let j = i; j < i + shipSize * step; j += step) {
        if (!this.allCells[j] || this.blockedCells.includes(this.allCells[j])) {
          continue outerLoop;
        }
        potentialShipCells.push(this.allCells[j]);
      }
      const xCoords = potentialShipCells.map(cell => cell?.slice(0, 1));
      const yCoords = potentialShipCells.map(cell => cell?.slice(1));

      switch (direction) {
        case "horizontal":
          if (
            checkIfElementsAreEqual(xCoords) &&
            checkIfElementsDifferByOne(yCoords)
          ) {
            arrayOfCells.push(this.allCells[i]);
          }
          break;
        case "vertical":
          if (
            checkIfElementsDifferByOne(xCoords) &&
            checkIfElementsAreEqual(yCoords)
          ) {
            arrayOfCells.push(this.allCells[i]);
          }
      }
    }

    if (!arrayOfCells.length) {
      throw new Error(`Not enough space for a ship size ${shipSize}`);
    }

    return arrayOfCells;
  }

  generateShipCoords(shipSize, opts = {}) {
    /**
     * Generates an array of coordinates for a ship
     * @param integer - shipSize
     * @param dictionary - opts. Can contain properties 'direction' and 'startingCell'
     * if 'direction' and 'startingCell' in opts are not given, they are randomly generated by the function
     * @return Set of coordinates. e.g. Set('A1','A2','A3')
     */

    let direction;
    let startingCell;

    direction =
      "direction" in opts ? opts.direction : this.chooseRandomDirection();

    const possibleStartingCells = this.possibleShipStartingCells(
      shipSize,
      direction
    );

    // if no opts.startingCell is given, it is randomly chosen from possibleStartingCells
    startingCell =
      "startingCell" in opts
        ? opts.startingCell
        : possibleStartingCells[
            this.randomInteger(possibleStartingCells.length - 1)
          ];

    if (!possibleStartingCells.includes(startingCell)) {
      throw new Error("Can't place this ship here");
    }

    const startingCellIndex = this.allCells.indexOf(startingCell);

    const step = direction === "horizontal" ? 1 : this.width;

    const shipCoords = new Set();

    for (
      let i = startingCellIndex;
      i < startingCellIndex + shipSize * step;
      i += step
    ) {
      shipCoords.add(this.allCells[i]);
    }

    return shipCoords;
  }

  getSurroundingCells(cell, includeCorners = false) {
    const index = this.allCells.indexOf(cell);

    if (index === -1) {
      throw new Error(
        `Element ${cell} is out of range on a ${this.height}x${this.width} board`
      );
    }

    // Checks if two cells are in the same rows
    // e.g. A1 and A2 -> true, A10 and B1 - false
    const isSameRow = (cell1, cell2) => {
      if (cell1 === cell2 && cell1 === undefined) {
        throw new Error("Both arguments can't be undefined");
      }
      return cell1?.slice(0, 1) === cell2?.slice(0, 1);
    };

    const surrondingCells = [];

    const center = this.allCells[index];
    const left = this.allCells[index - 1];
    const right = this.allCells[index + 1];
    const up = this.allCells[index - this.width];
    const down = this.allCells[index + this.width];

    surrondingCells.push(center);
    if (isSameRow(left, center)) surrondingCells.push(left);
    if (isSameRow(right, center)) surrondingCells.push(right);
    if (up) surrondingCells.push(up);
    if (down) surrondingCells.push(down);

    if (includeCorners) {
      const upLeft = this.allCells[index - this.width - 1];
      const upRight = this.allCells[index - this.width + 1];
      const downLeft = this.allCells[index + this.width - 1];
      const downRight = this.allCells[index + this.width + 1];

      if (isSameRow(left, center) && upLeft) surrondingCells.push(upLeft);
      if (isSameRow(right, center) && upRight) surrondingCells.push(upRight);
      if (isSameRow(left, center) && downLeft) surrondingCells.push(downLeft);
      if (isSameRow(right, center) && downRight)
        surrondingCells.push(downRight);
    }

    return surrondingCells;
  }

  placeShipAndBlockSurroundingCells(setOfCells, includeCorners = false) {
    this.allShips.push(new Set(setOfCells));
    this.remainingShips.push(new Set(setOfCells));
    for (const cell of setOfCells) {
      const surroundingCells = this.getSurroundingCells(cell, includeCorners);
      surroundingCells.forEach(e => {
        if (!this.blockedCells.includes(e)) {
          this.blockedCells.push(e);
        }
      });
    }
    return;
  }

  // Check if the cell clicked by the opponent contains a ship
  // Update availShips, hits, misses, checks if the game is lost
  makeMove(coord) {
    // Can't make move if the game is lost or click twice on the same cell
    if (this.gameLost || this.hits.has(coord) || this.misses.has(coord)) {
      return {
        coord: null,
        moveResult: null,
        remCellsNum: this.remainingShips.reduce((a, e) => a + e.size, 0),
        gameLost: this.gameLost,
      };
    }

    // Check each ship for the coordinate.
    // if found update the hits, if not found update the misses
    let moveResult;
    let sinkedShip = null;
    // label statement to break out of nested loops
    // more info https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label
    loop1: for (let ship of this.remainingShips) {
      for (const shipCell of ship) {
        if (shipCell === coord) {
          this.hits.add(coord); // add coord to hits
          ship.delete(shipCell); // remove coord from remainingShips
          // if there are no elements in the array left, then sink is true, otherwise, hit is true
          moveResult = ship.size ? "hit" : "sink";
          if (moveResult === "sink") {
            sinkedShip = this.allShips.find(e => e.has(coord));
          }
          break loop1;
        }
      }
    }

    if (!moveResult) {
      moveResult = "miss";
      this.misses.add(coord); // add coord to misses
    }

    // remove coord from untouched cells
    this.untouchedCells.splice(this.untouchedCells.indexOf(coord), 1);

    // Number of remaining cells needed to hit to lose the game.
    const remCellsNum = this.remainingShips.reduce((a, e) => a + e.size, 0);
    this.gameLost = !Boolean(remCellsNum);

    return {
      coord,
      moveResult,
      remCellsNum,
      gameLost: this.gameLost,
      sinkedShip,
    };
  }
}
